/***************************************************
*
* cismet GmbH, Saarbruecken, Germany
*
*              ... and it just works.
*
****************************************************/
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package de.cismet.jump.sld.editor;

import com.vividsolutions.jump.workbench.ui.style.StylePanel;

import org.apache.log4j.Logger;

import org.openide.util.NbBundle;

import java.awt.Cursor;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.DragSource;

import java.io.File;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.activation.ActivationDataFlavor;
import javax.activation.DataHandler;

import javax.swing.DropMode;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JTable;
import javax.swing.TransferHandler;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.filechooser.FileFilter;
import javax.swing.table.TableModel;

import de.cismet.cismap.commons.featureservice.AbstractFeatureService;
import de.cismet.cismap.commons.featureservice.DocumentFeatureService;
import de.cismet.cismap.commons.featureservice.FeatureServiceAttribute;
import de.cismet.cismap.commons.featureservice.H2FeatureService;
import de.cismet.cismap.commons.featureservice.ShapeFileFeatureService;
import de.cismet.cismap.commons.featureservice.WebFeatureService;

/**
 * DOCUMENT ME!
 *
 * @author   mroncoroni
 * @version  $Revision$, $Date$
 */
public class AllgemeinPanel extends javax.swing.JPanel implements StylePanel {

    //~ Static fields/initializers ---------------------------------------------

    private static final Logger LOG = Logger.getLogger(AllgemeinPanel.class);

    //~ Instance fields --------------------------------------------------------

    private final AbstractFeatureService service;
    private final AttrributeTableModel model;
    private final TableRowTransferHandler transferHandler = new TableRowTransferHandler();

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private org.jdesktop.swingx.JXTable attributeTable;
    private javax.swing.JButton butDataSource;
    private javax.swing.JCheckBox cbSelectable;
    private javax.swing.JLabel labAttributes;
    private javax.swing.JLabel lblName;
    private javax.swing.JLabel lblSelectable;
    private javax.swing.JLabel lblSource;
    private javax.swing.JScrollPane scrAttributeTable;
    private javax.swing.JTextField txtName;
    private javax.swing.JTextField txtSource;
    // End of variables declaration//GEN-END:variables

    //~ Constructors -----------------------------------------------------------

    /**
     * Creates new form AllgemeinPanel.
     *
     * @param  service  DOCUMENT ME!
     */
    public AllgemeinPanel(final AbstractFeatureService service) {
        this.service = service;
        initComponents();
        txtName.setText(service.getName());
        cbSelectable.setSelected(service.isSelectable());
        txtSource.setEditable(false);
        butDataSource.setVisible(false);

        if (service instanceof DocumentFeatureService) {
            final String source = ((DocumentFeatureService)service).getDocumentURI().toString();
            txtSource.setText(source);
        } else if (service instanceof WebFeatureService) {
            final String source = ((WebFeatureService)service).getHostname();
            txtSource.setText(source);
        } else {
            txtSource.setVisible(false);
            lblSource.setVisible(false);
        }

        if (service instanceof ShapeFileFeatureService) {
            if (((ShapeFileFeatureService)service).isFileNotFound()) {
                txtSource.setEditable(true);
                butDataSource.setVisible(true);
            }
        } else if (service instanceof H2FeatureService) {
            if (((H2FeatureService)service).isTableNotFound()) {
                txtSource.setEditable(true);
                txtSource.setVisible(true);
                lblSource.setVisible(true);
                butDataSource.setVisible(true);
            }
        }

        model = new AttrributeTableModel(service);
        attributeTable.setModel(model);
        attributeTable.setTransferHandler(transferHandler);
        attributeTable.setDropMode(DropMode.INSERT_ROWS);
        attributeTable.setDragEnabled(true);
    }

    //~ Methods ----------------------------------------------------------------

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        txtName = new javax.swing.JTextField();
        lblName = new javax.swing.JLabel();
        txtSource = new javax.swing.JTextField();
        lblSource = new javax.swing.JLabel();
        scrAttributeTable = new javax.swing.JScrollPane();
        attributeTable = new org.jdesktop.swingx.JXTable();
        labAttributes = new javax.swing.JLabel();
        lblSelectable = new javax.swing.JLabel();
        cbSelectable = new javax.swing.JCheckBox();
        butDataSource = new javax.swing.JButton();

        setLayout(new java.awt.GridBagLayout());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 15);
        add(txtName, gridBagConstraints);

        org.openide.awt.Mnemonics.setLocalizedText(
            lblName,
            org.openide.util.NbBundle.getMessage(AllgemeinPanel.class, "AllgemeinPanel.lblName.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 15, 5, 5);
        add(lblName, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(15, 5, 5, 15);
        add(txtSource, gridBagConstraints);

        org.openide.awt.Mnemonics.setLocalizedText(
            lblSource,
            org.openide.util.NbBundle.getMessage(AllgemeinPanel.class, "AllgemeinPanel.lblSource.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(15, 15, 5, 5);
        add(lblSource, gridBagConstraints);

        scrAttributeTable.setMinimumSize(new java.awt.Dimension(302, 282));
        scrAttributeTable.setPreferredSize(new java.awt.Dimension(402, 282));
        scrAttributeTable.setViewportView(attributeTable);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 15, 5, 15);
        add(scrAttributeTable, gridBagConstraints);

        org.openide.awt.Mnemonics.setLocalizedText(
            labAttributes,
            org.openide.util.NbBundle.getMessage(AllgemeinPanel.class, "AllgemeinPanel.labAttributes.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(15, 15, 5, 15);
        add(labAttributes, gridBagConstraints);

        org.openide.awt.Mnemonics.setLocalizedText(
            lblSelectable,
            org.openide.util.NbBundle.getMessage(AllgemeinPanel.class, "AllgemeinPanel.lblSelectable.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 15, 5, 5);
        add(lblSelectable, gridBagConstraints);

        org.openide.awt.Mnemonics.setLocalizedText(
            cbSelectable,
            org.openide.util.NbBundle.getMessage(AllgemeinPanel.class, "AllgemeinPanel.cbSelectable.text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 15);
        add(cbSelectable, gridBagConstraints);

        org.openide.awt.Mnemonics.setLocalizedText(
            butDataSource,
            org.openide.util.NbBundle.getMessage(
                AllgemeinPanel.class,
                "AllgemeinPanel.butDataSource.text",
                new Object[] {})); // NOI18N
        butDataSource.addActionListener(new java.awt.event.ActionListener() {

                @Override
                public void actionPerformed(final java.awt.event.ActionEvent evt) {
                    butDataSourceActionPerformed(evt);
                }
            });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.insets = new java.awt.Insets(15, 5, 5, 15);
        add(butDataSource, gridBagConstraints);
    } // </editor-fold>//GEN-END:initComponents

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void butDataSourceActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_butDataSourceActionPerformed
        final JFileChooser fileChooser = new JFileChooser();

        fileChooser.setFileFilter(new FileFilter() {

                @Override
                public boolean accept(final File f) {
                    final String fileName = f.getAbsolutePath();

                    return fileName.toUpperCase().endsWith("SHP") || fileName.toUpperCase().endsWith("DBF");
                }

                @Override
                public String getDescription() {
                    return "Shapes";
                }
            });

        final int userAction = fileChooser.showDialog(this, "ausw√§hlen");

        if (userAction == JFileChooser.APPROVE_OPTION) {
            final File selectedFile = fileChooser.getSelectedFile();

            if (selectedFile != null) {
                txtSource.setText("file://" + selectedFile.getAbsolutePath());
            }
        }
    } //GEN-LAST:event_butDataSourceActionPerformed

    @Override
    public String getTitle() {
        return NbBundle.getMessage(AllgemeinPanel.class, "AllgemeinPanel.getTitle()");
    }

    @Override
    public void updateStyles() {
        service.setName(txtName.getText());
        service.setSelectable(cbSelectable.isSelected());
    }

    @Override
    public String validateInput() {
        return null;
    }

    /**
     * DOCUMENT ME!
     *
     * @return  DOCUMENT ME!
     */
    public String getSource() {
        return txtSource.getText();
    }

    /**
     * synchronises the current service with the attribute options from the table.
     */
    public void syncServiceWithModel() {
        final Map<String, FeatureServiceAttribute> attributeMap = service.getFeatureServiceAttributes();

        for (final String attr : model.attributes) {
            final FeatureServiceAttribute fsa = attributeMap.get(attr);
            fsa.setVisible(model.visibilityMap.get(attr));
            fsa.setNameElement(model.nameElementMap.get(attr));
            fsa.setAlias(model.aliasMap.get(attr));
        }

        service.setOrderedFeatureServiceAttributes(model.attributes);
    }

    //~ Inner Classes ----------------------------------------------------------

    /**
     * DOCUMENT ME!
     *
     * @version  $Revision$, $Date$
     */
    private class AttrributeTableModel implements TableModel {

        //~ Instance fields ----------------------------------------------------

        String[] cols = {
                NbBundle.getMessage(AttrributeTableModel.class, "AllgemeinPanel.AttributeTableModel.visibility"),
                NbBundle.getMessage(AttrributeTableModel.class, "AllgemeinPanel.AttributeTableModel.name"),
                NbBundle.getMessage(AttrributeTableModel.class, "AllgemeinPanel.AttributeTableModel.alias"),
                NbBundle.getMessage(AttrributeTableModel.class, "AllgemeinPanel.AttributeTableModel.nameElement")
            };
        List<String> attributes;
        Map<String, String> aliasMap;
        Map<String, Boolean> visibilityMap;
        Map<String, Boolean> nameElementMap;
        List<TableModelListener> listener = new ArrayList<TableModelListener>();

        //~ Constructors -------------------------------------------------------

        /**
         * Creates a new AttrributeTableModel object.
         *
         * @param  service  DOCUMENT ME!
         */
        public AttrributeTableModel(final AbstractFeatureService service) {
            attributes = service.getOrderedFeatureServiceAttributes();
            aliasMap = new HashMap<String, String>();
            visibilityMap = new HashMap<String, Boolean>();
            nameElementMap = new HashMap<String, Boolean>();
            final Map<String, FeatureServiceAttribute> attributeMap = service.getFeatureServiceAttributes();

            for (final String attr : attributes) {
                aliasMap.put(attr, attributeMap.get(attr).getAlias());
                nameElementMap.put(attr, attributeMap.get(attr).isNameElement());
                visibilityMap.put(attr, attributeMap.get(attr).isVisible());
            }
        }

        //~ Methods ------------------------------------------------------------

        @Override
        public int getRowCount() {
            return attributes.size();
        }

        @Override
        public int getColumnCount() {
            return cols.length;
        }

        @Override
        public String getColumnName(final int columnIndex) {
            return cols[columnIndex];
        }

        @Override
        public Class<?> getColumnClass(final int columnIndex) {
            switch (columnIndex) {
                case 0: {
                    return Boolean.class;
                }
                case 3: {
                    return Boolean.class;
                }
                default: {
                    return String.class;
                }
            }
        }

        @Override
        public boolean isCellEditable(final int rowIndex, final int columnIndex) {
            if (columnIndex == 1) {
                return false;
            } else {
                return true;
            }
        }

        @Override
        public Object getValueAt(final int rowIndex, final int columnIndex) {
            switch (columnIndex) {
                case 0: {
                    return visibilityMap.get(attributes.get(rowIndex));
                }
                case 1: {
                    final String value = attributes.get(rowIndex);
                    return (value.startsWith("app:") ? value.substring(4) : value);
                }
                case 2: {
                    final String alias = aliasMap.get(attributes.get(rowIndex));
                    return ((alias == null) ? "" : alias);
                }
                case 3: {
                    return nameElementMap.get(attributes.get(rowIndex));
                }
                default: {
                    return String.class;
                }
            }
        }

        @Override
        public void setValueAt(final Object aValue, final int rowIndex, final int columnIndex) {
            switch (columnIndex) {
                case 0: {
                    if (aValue instanceof Boolean) {
                        visibilityMap.put(attributes.get(rowIndex), (Boolean)aValue);
                    }
                    break;
                }
                case 2: {
                    if (aValue instanceof String) {
                        String newValue = null;

                        if ((aValue != null) && !((String)aValue).trim().equals("")) {
                            newValue = (String)aValue;
                        }

                        aliasMap.put(attributes.get(rowIndex), newValue);
                    }
                    break;
                }
                case 3: {
                    if (aValue instanceof Boolean) {
                        nameElementMap.put(attributes.get(rowIndex), (Boolean)aValue);
                    }
                    break;
                }
            }
        }

        @Override
        public void addTableModelListener(final TableModelListener l) {
            listener.add(l);
        }

        @Override
        public void removeTableModelListener(final TableModelListener l) {
            listener.remove(l);
        }

        /**
         * DOCUMENT ME!
         */
        private void fireTableChanged() {
            for (final TableModelListener l : listener) {
                l.tableChanged(new TableModelEvent(this));
            }
        }

        /**
         * DOCUMENT ME!
         *
         * @param  source  DOCUMENT ME!
         * @param  dest    DOCUMENT ME!
         */
        public void moveRowsTo(final Integer[] source, final int dest) {
            final List<String> newAttributes = new ArrayList<String>();
            Arrays.sort(source);

            for (int sourceIndex = 0; sourceIndex < attributes.size(); ++sourceIndex) {
                if ((sourceIndex != dest) && (Arrays.binarySearch(source, sourceIndex) < 0)) {
                    newAttributes.add(attributes.get(sourceIndex));
                } else if (sourceIndex == dest) {
                    for (final Integer i : source) {
                        newAttributes.add(attributes.get(i));
                    }

                    if (Arrays.binarySearch(source, sourceIndex) < 0) {
                        newAttributes.add(attributes.get(sourceIndex));
                    }
                }
            }

            if (dest == attributes.size()) {
                for (final Integer i : source) {
                    newAttributes.add(attributes.get(i));
                }
            }

            attributes = newAttributes;
            fireTableChanged();
        }
    }

    /**
     * Allows to move a row per DnD to an other position in the table.
     *
     * @version  $Revision$, $Date$
     */
    private class TableRowTransferHandler extends TransferHandler {

        //~ Instance fields ----------------------------------------------------

        private final DataFlavor rowFlavor;

        //~ Constructors -------------------------------------------------------

        /**
         * Creates a new TableRowTransferHandler object.
         */
        public TableRowTransferHandler() {
            rowFlavor = new ActivationDataFlavor(
                    Integer[].class,
                    DataFlavor.javaJVMLocalObjectMimeType,
                    "Array of items");
        }

        //~ Methods ------------------------------------------------------------

        @Override
        protected Transferable createTransferable(final JComponent c) {
            final JTable table = (JTable)c;
            final ArrayList<Integer> list = new ArrayList<Integer>();

            for (final int i : table.getSelectedRows()) {
                list.add(i);
            }

            final Integer[] transferedObjects = list.toArray(new Integer[list.size()]);

            return new DataHandler(transferedObjects, rowFlavor.getMimeType());
        }

        @Override
        public boolean canImport(final TransferHandler.TransferSupport info) {
            final JTable t = (JTable)info.getComponent();
            final boolean b = info.isDrop() && info.isDataFlavorSupported(rowFlavor);

            t.setCursor(b ? DragSource.DefaultMoveDrop : DragSource.DefaultMoveNoDrop);

            return b;
        }

        @Override
        public int getSourceActions(final JComponent c) {
            return TransferHandler.COPY_OR_MOVE;
        }

        @Override
        public boolean importData(final TransferHandler.TransferSupport info) {
            final JTable target = (JTable)info.getComponent();
            final JTable.DropLocation dl = (JTable.DropLocation)info.getDropLocation();
            final AttrributeTableModel model = (AttrributeTableModel)target.getModel();
            int index = dl.getRow();
            final int max = model.getRowCount();

            if ((index < 0) || (index > max)) {
                index = max;
            }
            target.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));

            try {
                final Object[] values = (Object[])info.getTransferable().getTransferData(rowFlavor);

                model.moveRowsTo((Integer[])values, index);
                return true;
            } catch (Exception e) {
                LOG.error("Error while importing data after DnD operation.", e);
            }

            return false;
        }

        @Override
        protected void exportDone(final JComponent c, final Transferable t, final int act) {
            c.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }
    }
}
